# New CRD Design - Project Model & Claim/Class Pattern

This document explains the new CRD design for OpenChoreo that follows the Developer abstractions with the Claim/Class pattern. 
This design aim to provides better abstractions for developers while allowing platform engineers to maintain control over configuration and resource provisioning.

## Design Principles

### Claim/Class Pattern with Environment Bindings
- **Classes**: Platform Engineers (PEs) define templates and governance rules via Classes
- **Claims**: Developers create environment-independent intent resources
- **Bindings**: Environment-bound copies of Claims generated by controllers
- **Releases**: Internal resources with final rendered Kubernetes resources

### Developer vs Platform Engineer Separation
- **Developers** think in terms of: Build, Workload, Connections, APIs
- **Platform Engineers** define: Classes, policies, resource templates, governance rules
- **Controllers** handle: Resource generation, validation, orchestration, environment binding

### API vs Endpoint Design Decision
**Why API instead of Endpoint?**
- **API**: Reserved for managed API types (REST, GraphQL) that require full API management capabilities
- **Simple Network Endpoints**: Basic endpoints (TCP, UDP) are defined directly in Workload specifications
- **Controller Promotion**: Controllers can promote workload endpoints to managed API resources when API management is needed
- **Backstage Alignment**: Aligns with Backstage entity model where API represents managed APIs with specifications
- **Clear Separation**: Distinguishes between simple network exposure vs sophisticated API management

## Developer-Facing Abstractions

### Project
**Purpose**: Logical grouping of related components that collectively define an application workloads or bounded context

**Key Features**:
- Serves as the main organizational boundary for source code, deployments, and network policies
- Defines team or application-level boundaries
- Governs internal access across components
- Provides deployment isolation and visibility scope
- Controls component communication internally and with external systems

**Current Implementation**: ProjectV2 (`api/v1/project_types.go`)

### Component
**Purpose**: Deployable piece of software (service, webapp, task, API proxy)

**Key Features**:
- Belongs to exactly one Project
- Declares its type (service, webapp, task, api)
- References source code location (Git repo, image registry)
- Environment-agnostic (not bound to specific environments)
- Orchestrates creation of environment-independent Workload, API, and Connection resources

**Current Implementation**: ComponentV2 (`api/v1/componentv2_types.go`)

### DeploymentTrack
**Purpose**: Represents a line of development or delivery stream for a component

**Key Features**:
- Aligned with Git branches (main, release-1.0, feature-xyz)
- Can represent API versions (v1, v2) or meaningful evolution labels
- Optional for simple use cases (defaults to "default" track)
- Enables multiple deployment streams from same codebase

**NOTE**: This is an optional abstraction, not required for all components. The initial implementation does not include the DeploymentTrack support, but it can be added later if needed.

### API
**Purpose**: Managed API endpoints with full API management capabilities

**Key Features**:
- For managed API types only (REST, GraphQL) that support API management
- Simple network endpoints (TCP, UDP) are defined in Workload spec instead
- Includes HTTP routing, versioning, authentication, rate limits, scopes
- Independently versioned from component
- Enables controlled exposure (organization-wide or public)
- Integrates with API gateways and developer portals

**Current Implementation**: API with API Management features (`api/v1/endpointv2_types.go`)
**TODO**: Rename from EndpointV2 to API to reflect its purpose

## Core CRD Architecture

### Workload Pattern

The Workload captures the runtime contract of a Component within a DeploymentTrack. It defines how the component runs: container image, ports, environment variables, and runtime dependencies.

#### WorkloadClass
**Purpose**: Platform Engineer-defined templates for workload configurations

**Key Features**:
- Defines resource limits, security policies, deployment strategies
- Provides governance and standardization across the organization
- Referenced by Workload claims

**File**: `api/v1/workloadclass_types.go`

#### Workload (Developer Intent)
**Purpose**: Environment-independent runtime contract that captures everything needed to run a component

**Key Features**:
- **Runtime Contract**: Defines ports, protocols, dependencies, container image
- **Environment-independent**: Like Component, it is not bound to specific environments
- **Simple Endpoints**: Includes basic network endpoints (TCP, UDP) in spec
- **Versioned**: Linked to specific track, changes frequently (e.g., after CI builds)
- **Class Reference**: Inherits configuration from WorkloadClass
- **Auto-generated**: Created by ComponentV2 controller
- **Code Reuse**: Enables single codebase backing multiple components with distinct contracts

**File**: `api/v1/workload_types.go`

#### WorkloadRelease
**Purpose**: Internal resource containing final rendered Kubernetes resources

**Key Features**:
- Generated by Workload controller
- Not committed to GitOps repository
- Applied directly to data plane clusters
- Contains Deployments, Services, NetworkPolicies, etc.

**File**: `api/v1/workloadrelease_types.go`

### API Pattern

#### APIClass
**Purpose**: Platform Engineer-defined templates for managed API configurations

**Key Features**:
- Defines base configurations for managed API types (REST, GraphQL)
- Configures exposure levels: Project, Organization, Public
- Sets API Management policies (rate limiting, authentication)
- Some API types may not support all exposure levels

**File**: `api/v1/endpointclass_types.go` (to be renamed to `apiclass_types.go`)

#### API (Developer Intent)
**Purpose**: Environment-independent managed API endpoints with full API management capabilities

**Key Features**:
- **Managed APIs Only**: For REST, GraphQL and other types requiring API management
- **Simple Endpoints**: TCP, UDP endpoints are defined in Workload spec instead
- **Environment-independent**: Not bound to specific environments
- **Exposure Levels**:
  - **Project**: Accessible only within the project
  - **Organization**: Accessible across projects within organization
  - **Public**: Exposed to the internet
- **Backend Targets**: Workloads or external services
- **API Management**: Different policies per exposure level

**File**: `api/v1/endpointv2_types.go` (to be renamed to `api_types.go`)

#### APIBinding
**Purpose**: Environment-bound copy of API intent

**Key Features**:
- Contains exact copy of API spec plus environment reference
- Generated by API controller or during environment promotion
- Committed to GitOps repository
- One APIBinding per environment per API

**File**: To be created as `api/v1/apibinding_types.go`

#### APIRelease
**Purpose**: Internal resource with final rendered Kubernetes networking resources

**Key Features**:
- Generated by APIBinding controller
- Not committed to GitOps repository
- Contains Ingress, Gateway, HTTPRoutes, etc.

**File**: `api/v1/endpointrelease_types.go` (to be renamed to `apirelease_types.go`)

## Runtime & Deployment Abstractions

### Environment
**Purpose**: Target runtime space (dev, staging, prod) with infrastructure-specific configuration

**Key Features**:
- Encapsulates cluster bindings, gateway setups, secrets, policies
- Where actual deployments occur
- May have constraints/validations (e.g., only approved workloads in prod)
- Infrastructure-specific configuration separate from application logic

### Binding Resources
**Purpose**: Environment-bound copies of developer intent resources

**Key Features**:
- **WorkloadBinding**: Environment-bound copy of Workload
- **APIBinding**: Environment-bound copy of API
- **ConnectionBinding**: Environment-bound copy of Connection
- **Promotion Vehicle**: Enables progressive delivery (dev → staging → prod)
- **Always Derived**: Generated by controllers or during environment promotion
- **GitOps Committed**: Stored in GitOps repository for audit trail
- **Enables Reuse**: Same intent deployed across multiple environments

**Binding Generation**:
- Developers author: Component (which creates Workload, API, Connection)
- Controllers generate: Bindings (Workload + API + Connection + Environment)
- Promotion = copying Bindings to different environments in GitOps

## Controller Flow & GitOps Integration

### Direct Kubernetes Mode
1. Developer applies ComponentV2 CRD
2. Component controller creates Workload, API, and Connection resources
3. Individual controllers (Workload, API, Connection) create their respective Binding resources for each environment
4. Binding controllers (WorkloadBinding, APIBinding, ConnectionBinding) create Release resources
5. Release controllers apply final rendered resources to data plane clusters

### GitOps Mode (with Flux)
1. Developer applies ComponentV2 CRD (synced by Flux)
2. Component controller generates Workload, API, and Connection YAMLs and commits to GitHub
3. Flux syncs the generated resources to cluster
4. Individual controllers generate Binding YAMLs for each environment and commit to GitHub
5. Flux syncs the Binding resources to cluster
6. Binding controllers create Release resources directly in cluster (not committed to GitOps)
7. Release controllers apply final rendered resources to data plane clusters

### GitCommitRequest
**Purpose**: Optional controller for GitOps workflow automation

**Key Features**:
- Only used when GitOps feature is enabled
- Used by Component, Workload, API, and Connection controllers to commit resources to GitOps repository
- Commits both intent resources and their Binding copies to GitOps repository
- Supports both mono-repo and multi-repo setups
- **Note**: Currently under development with security improvements needed

**File**: `api/v1/gitcommitrequest_types.go`

### Benefits of New Design
- **Clean Separation**: GitOps-committed resources vs runtime-only resources
- **Environment Promotion**: Handled through Binding resource copies in GitOps
- **Audit Trail**: All user-facing intent preserved in Git while keeping cluster operations clean


## References

Sample YAMLs and examples for the new CRD design can be found in the `new-design-sample` directory.

